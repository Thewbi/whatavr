= Toolchain =

== The .DSEG directive and stubs that load variables into SRAM ==

https://electronics.stackexchange.com/questions/129528/avr-microcontrollers-who-initilizes-assembly-data-segment-and-what-is-the-pur

https://onlinedocs.microchip.com/pr/GUID-E06F3258-483F-4A7B-B1F8-69933E029363-en-US-2/index.html?GUID-98474996-9238-45DC-8DBF-7B03AD9F1074

.DSEG, .ESEG and .CSEG are separate address spaces and they are separate blocks of memory.

.DSEG is the data segment and is implemented by a SRAM chip inside the microcontroller.
It has it's own pointer which addresses byte-wise (not word-wise).
The pointers initial value is right after the end of I/O space (0x60 for devices without extended I/O, 
0x100 or more for devices with extended I/O) 
The pointer can be modified using the .ORG instruction.

.CSEG is the code segment aka. program memory and it is implemented by a flash memory chip inside the microcontroller.
It is written by the programmer hardware during microcontoller flashing when the application is downloaded to the chip.
It has it's own pointer which addresses word-wise (not byte-wise as opposed to the .DSEG and .ESEG pointers).
The pointers initial value is 0x0000.
The pointer can be modified using the .ORG instruction.

No it is important what the meaning of .DSEG and .CSEG semantically means.
.DSEG means that the user wants to modify the content of the SRAM memory.
.CSEG means that the user wants to modify the content of flash memory.

The important aspect here is that the flasher harware can actually modify the flash chip but it cannot
modify SRAM since SRAM is lost once a power-cycle happens! The only part that can actually modify
SRAM is the microcontroller itself, when it executes that application!

When the user wants to modify SRAM, there must be some piece of code stored in flash that causes
the Microcontroller to initialize SRAM as described inside the assembler file when the .DSEG
instruction is used! How does this work? (As we will learn shortly, this piece of code is the
stub code generated by the linker! If no linker is used, then SRAM remains completely empty!)

When using this code in an assembler like the Microchip Studio 7 (Assembler Project Type) for example:

```
.DSEG ; Start data segment (SRAM)
.ORG 0x120 ; Set SRAM address to hex 120 
consts_dseg: .DB 1, 2, 3, 4, 5
```

and after compilation running this assembler program on the simulator, the data segment (SRAM) will not
contain the bytes 1, 2, 3, 4, 5 as defined here!

Clearly the users intentions of manipulating .DSEG are ignored!
Is this a bug? No it is not a bug!

When using .DB inside the .CSEG (code segment, flash memory) then .ORG and .DB will work without
the linker. The reason is that the assembler will just generate a code segment that contains the
constants as if they where encoded instructions. The code segment is then placed into flash 
memory during application upload (flashing the flash memory with the code segments) and from 
there on, the constants are available in the code segment. Even after any power-cycle.

When using the .DB and .ORG assemble instructions inside the data segment (SRAM) then the 
situation is completely different! The SRAM block is not flashed by the uploader! SRAM
is only accessed by the Microcontroller and not by the flasher hardware (such as AVR-MKII for example!)
This means SRAM is only manipulated after the application has been flashed and is run by the
microcontroller. Hence SRAM is completely empty after start!

The .DSEG and .ORG statements as well as the .DB instruction are not immediately converted into 
statements by the assembler! Therefore the microcontroller will not execute any statements! 
The defined constants will not magically appear in SRAM when the system starts! Someone has to 
copy the values into SRAM so that the SRAM is initialized!

Therefore .DSEG, .ORG and .DB instructions are metadata for the toolchain, specifically for
the linker. The linker has to generate stub code and link that stub code into the application binary.
The purpose of the stub code is to contain instructions that will actually cause the microcontroller
to load the constants from the application binary into the data segment (SRAM)! Basically the stub
code will read the constants temporarily stored in FLASH and write them into SRAM!

But the Assembler Project Type in Microchip Studio does not execute a full pipeline! It does
not execute a linker so there is no stub code! The Assembler outputs object files (.obj).
A toolchain now has to furhter process those object files using a linker! 

So in Assembler Project Type in Microchip Studio, .CSEG constants will work but .DSEG constants
will not work!

To make it work a complete toolchain (assembler, linker) is required!


